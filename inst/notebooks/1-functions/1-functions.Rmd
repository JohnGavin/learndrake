---
title: "The functions of the customer churn workflow"
output:
  html_document:
    df_print: paged
---

# Do first

1. Navigate to the `1-functions/` folder.
2. Open `1-functions.Rproj` as an RStudio project in a new R session. (Click on `1-functions.Rproj` in RStudio's file manager.)
3. Check that your working directory is correct. It should be `1-functions/`.

```{r}
basename(getwd()) # Should be "1-functions"
```

4. Run the code chunk below. (Click on the green arrow on the right.)

```{r, include = FALSE}
source("../config/options.R")
```

# About

In this notebook, we will explore Keras models that predict customer behavior, and we will express our implementation in 7 custom functions. These functions are the essential building blocks of the `drake` workflows to come.

1. `split_data()`: read the customer churn data and split it into a training set and a test set.
2. `prepare_recipe()`: get the data ready for the Keras models.
3. `define_model()`: define a Keras model.
4. `train_model()`: call `define_model()` to define a Keras model, fit it to the testing data, and return the fitted model object.
5. `test_accuracy()`: get the test accuracy of a fitted Keras model.
6. `test_model()`: call `train_model()` and `test_accuracy()` to train a model and summarize its testing accuracy.
7. `train_best_model()`: train the highest-accuracy model we have found so far.

# Customer churn

Using the IBM Watson Telco Customer Churn dataset, we will train deep neural networks to classify customers. The goal is to predict who will cancel their subscription services such as internet and television. Cancellation, or "customer churn", is a problem that companies care about monitoring. For additional background on this example, please read <https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn>.

# Packages

Our functions will need the following R packages. Run the code chunk below to load them now. (Click on the green arrow on the right.)

```{r, message = FALSE}
# Build and train deep neural nets.
# https://keras.rstudio.com/index.html
library(keras)

# Custom data preprocessing procedures.
# https://tidymodels.github.io/recipes/
library(recipes)

# Data resampling. We will use it to split the customer churn dataset
# into training and test sets for our deep learning models.
# https://tidymodels.github.io/rsample
library(rsample)

# Multiple packages that support clean code and tidy data.
# https://tidyverse.tidyverse.org/
library(tidyverse)

# Tidy methods to measure model performance.
# We will use it to compute accuracy on the testing set.
# https://tidymodels.github.io/yardstick
library(yardstick)
```

Check if TensorFlow is installed. The code below should display the TensorFlow version. Do not worry about other console messages.

```{r, message = FALSE}
library(tensorflow)
tf_version()
```

# `split_data()`

For machine learning, we need to split the customers (rows) into a training dataset and a testing dataset.

```{r}
split_data <- function(churn_file) {
  read_csv(churn_file, col_types = cols()) %>%
    initial_split(prop = 0.3) # from the rsample package
}
```

Try out the function.

```{r}
churn_data <- split_data("../data/customer_churn.csv")
```

The training set has 2113 customers (rows) and the testing set has 4930.

```{r}
print(churn_data)
```

Functions from [`rsample`](https://tidymodels.github.io/rsample) can recover the training and testing sets.

```{r}
training(churn_data)
```

```{r}
testing(churn_data)
```

The dataset has 21 variables (columns).

```{r}
# View(training(churn_data))
glimpse(training(churn_data))
```

`Churn` is our response variable, and `customerID` identifies customers.

```{r}
training(churn_data) %>%
  select(customerID, Churn) %>%
  print()
```

The rest of the variables are covariates.

- Subscriptions services: `PhoneService`, `MultipleLines`, `InternetService`, `OnlineSecurity`, `OnlineBackup`, `TechSupport`, `DeviceProtection`, `StreamingTV`, and `StreamingMovies`.
- Account information: `Contract`, `PaymentMethod`, `PaperlessBilling`, `tenure`, `MonthlyCharges`, and `TotalCharges`.
- Demographic information: `gender`, `SeniorCitizen`, `Partner`, and `Dependents`.

# `prepare_recipe()`

`prepare_recipe()` gets our data ready for our models. It accepts a data frame with a train/test and returns a recipe object generated by the `recipes` package.

```{r}
prepare_recipe <- function(churn_data) {
  churn_data %>%
    # Just preprocess the training data.
    training() %>%
    # Start defining a new recipe.
    recipe(Churn ~ .) %>%
    # Remove the customerID variable from the data.
    step_rm(customerID) %>%
    # Remove missing values.
    step_naomit(all_outcomes(), all_predictors()) %>%
    # Partition the tenure variable into 6 bins.
    step_discretize(tenure, options = list(cuts = 6)) %>%
    # Take the log of TotalCharges to strengthen the association with Churn.
    step_log(TotalCharges) %>%
    # Encode the Churn variable as a 0-1 indicator variable.
    step_mutate(Churn = ifelse(Churn == "Yes", 1, 0)) %>%
    # Encode each categorical variable as a collection of 0-1 indicators.
    step_dummy(all_nominal(), -all_outcomes()) %>%
    # Center all covariates.
    step_center(all_predictors(), -all_outcomes()) %>%
    # Scale all covariates.
    step_scale(all_predictors(), -all_outcomes()) %>%
    # Run the recipe on the data.
    prep()
}
```

Let's try out the function to make sure it works.

```{r}
churn_recipe <- prepare_recipe(churn_data)
print(churn_recipe)
```

Later on, we will need to retrieve the preprocessed training data with `juice()`.

```{r}
juice(churn_recipe, all_outcomes())
```

```{r}
juice(churn_recipe, all_predictors())
```

Keras will want our predictors to be in matrix form.

```{r}
juice(churn_recipe, all_predictors(), composition = "matrix")[1:6, 1:4]
```

When we compute accuracy later on, we will use `bake()` to preprocess the testing data.

```{r}
bake(churn_recipe, testing(churn_data))
```

# `define_model()`

Before we fit a model, we need to define it. `define_model()` function encapsulates our Keras model definition. It serves as custom shorthand that will make our other functions easier to read.

```{r}
define_model <- function(churn_recipe, units1, units2, act1, act2, act3) {
  input_shape <- ncol(
    juice(churn_recipe, all_predictors(), composition = "matrix")
  )
  keras_model_sequential() %>%
    layer_dense(
      units = units1,
      kernel_initializer = "uniform",
      activation = act1,
      input_shape = input_shape
    ) %>%
    layer_dropout(rate = 0.1) %>%
    layer_dense(
      units = units2,
      kernel_initializer = "uniform",
      activation = act2
    ) %>%
    layer_dropout(rate = 0.1) %>%
    layer_dense(
      units = 1,
      kernel_initializer = "uniform",
      activation = act3
    )
}
```

Let's check if it returns the model definition we expect.

```{r}
define_model(churn_recipe, 16, 16, "relu", "relu", "sigmoid") %>%
  print()
```

# `train_model()`

Next, we need to fit a model and return the fitted model object.

```{r}
train_model <- function(
  churn_recipe,
  units1 = 16,
  units2 = 16,
  act1 = "relu",
  act2 = "relu",
  act3 = "sigmoid"
) {
  model <- define_model(churn_recipe, units1, units2, act1, act2, act3)
  compile(
    model,
    optimizer = "adam",
    loss = "binary_crossentropy",
    metrics = c("accuracy")
  )
  x_train_tbl <- juice(
    churn_recipe,
    all_predictors(),
    composition = "matrix"
  )
  y_train_vec <- juice(churn_recipe, all_outcomes()) %>%
    pull()
  fit(
    object = model,
    x = x_train_tbl,
    y = y_train_vec,
    batch_size = 32,
    epochs = 32,
    validation_split = 0.3,
    verbose = 0
  )
  model
}
```

Try it out.

```{r}
model <- train_model(churn_recipe)

print(model)
```

# `test_accuracy()`

This function takes model object from `train_model()` and computes the accuracy on the testing data.

```{r}
test_accuracy <- function(churn_data, churn_recipe, model) {
  testing_data <- bake(churn_recipe, testing(churn_data))
  x_test_tbl <- testing_data %>%
    select(-Churn) %>%
    as.matrix()
  y_test_vec <- testing_data %>%
    select(Churn) %>%
    pull()
  yhat_keras_class_vec <- model %>%
    predict_classes(x_test_tbl) %>%
    as.factor() %>%
    fct_recode(yes = "1", no = "0")
  yhat_keras_prob_vec <-
    model %>%
    predict_proba(x_test_tbl) %>%
    as.vector()
  test_truth <- y_test_vec %>%
    as.factor() %>%
    fct_recode(yes = "1", no = "0")
  estimates_keras_tbl <- tibble(
    truth = test_truth,
    estimate = yhat_keras_class_vec,
    class_prob = yhat_keras_prob_vec
  )
  estimates_keras_tbl %>%
    conf_mat(truth, estimate) %>%
    summary() %>%
    filter(.metric == "accuracy") %>%
    pull(.estimate)
}
```

Try it out.

```{r}
test_accuracy(churn_data, churn_recipe, model)
```


# `test_model()`

`test_model()` is the top-level modeling function we will use in `drake`. It trains a model and reports its accuracy on the test dataset. It uses the previously defined `train_model()` and `test_accuracy()` functions.

```{r}
test_model <- function(
  churn_data,
  churn_recipe,
  units1 = 16,
  units2 = 16,
  act1 = "relu",
  act2 = "relu",
  act3 = "sigmoid"
) {
  model <- train_model(churn_recipe, units1, units2, act1, act2, act3)
  accuracy <- test_accuracy(churn_data, churn_recipe, model)
  tibble(
    accuracy = accuracy,
    units1 = units1,
    units2 = units2,
    act1 = act1,
    act2 = act2,
    act3 = act3
  )
}
```

Try it out.

```{r, output = FALSE}
run_relu <- test_model(act1 = "relu", churn_data, churn_recipe)
run_sigmoid <- test_model(act1 = "sigmoid", churn_data, churn_recipe)

run_relu
```

# `train_best_model()`

Now, let's train the model with the highest accuracy.

```{r}
train_best_model <- function(best_run, churn_recipe) {
  train_model(
    churn_recipe,
    best_run$units1,
    best_run$units2,
    best_run$act1,
    best_run$act2,
    best_run$act3
  )
}
```

Try it out.

```{r}
best_run <- bind_rows(run_relu, run_sigmoid) %>%
  filter(accuracy == max(accuracy))

train_best_model(best_run, churn_recipe = churn_recipe)
```
