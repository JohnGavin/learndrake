---
title: "Static branching"
subtitle: "Concise shorthand for long plans"
output:
  learnr::tutorial:
    allow_skip: false
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(drake)
library(DT)
library(learnr)
library(praise)
library(styler)
library(tidyverse)
library(visNetwork)
options(
  drake_make_menu = FALSE,
  drake_clean_menu = FALSE,
  warnPartialMatchArgs = FALSE,
  crayon.enabled = FALSE,
  readr.show_progress = FALSE,
  tibble.print_max = 25
)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
laud <- function() {
  praise("${Exclamation}! ${Adverb} ${adjective} answer.")
}
drake_checker <- function(
  label,
  user_code,
  solution_code,
  check_code,
  envir_result,
  evaluate_result,
  envir_prep,
  ...
) {
  out <- eval(parse(text = user_code))
  exp <- eval(parse(text = check_code))
  ans <- same_plan(out, exp)
  msg <- ifelse(ans, laud(), "Try again.")
  list(message = msg, correct = ans, location = "append")
}
tutorial_options(exercise.checker = drake_checker)
safe_deparse <- function (x, collapse = "\n") {
  paste(deparse(x, control = c("keepInteger", "keepNA")), collapse = collapse)
}
deparse_commands <- function (x) {
  unlist(lapply(x, safe_deparse, collapse = " "))
}
deparse_plan <- function(plan) {
  plan$command <- deparse_commands(plan$command)
  plan
}
same_plan <- function (out, exp) {
  out <- deparse_plan(out)
  exp <- deparse_plan(exp)
  out <- out[order(out$target), ]
  exp <- exp[order(exp$target), ]
  all(out$target == exp$target & out$command == exp$command)
}
dp_graph <- function(plan) {
  vis_drake_graph(
    plan = plan,
    cache = storr::storr_environment(),
    session_info = FALSE,
    history = FALSE,
    main = "",
    hover = TRUE,
    from = file_store("data/customer_churn.csv")
  )
}
dp_table <- function(plan) {
  DT::datatable(deparse_plan(plan), rownames = FALSE)
}
```

## Problems with large plans

In real life, workflows grow and `drake` plans get cumbersome. To seriously model customer churn, we need to test many more models.

```r
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run_relu = test_model(act1 = "relu", churn_data, churn_recipe),
  run_elu = test_model(act1 = "elu", churn_data, churn_recipe),
  run_selu = test_model(act1 = "selu", churn_data, churn_recipe),
  run_hard_sigmoid = test_model(act1 = "hard_sigmoid", churn_data, churn_recipe),
  run_linear = test_model(act1 = "linear", churn_data, churn_recipe),
  run_sigmoid = test_model(act1 = "sigmoid", churn_data, churn_recipe),
  run_softmax = test_model(act1 = "softmax", churn_data, churn_recipe),
  run_softplus = test_model(act1 = "softplus", churn_data, churn_recipe),
  run_softsign = test_model(act1 = "softsign", churn_data, churn_recipe),
  run_tanh = test_model(act1 = "tanh", churn_data, churn_recipe),
  run_exponential = test_model(act1 = "exponential", churn_data, churn_recipe)
)
```

```{r problem}
question(
  "Anything wrong with this plan?",
  correct = laud(),
  incorrect = "Let's talk.",
  allow_retry = TRUE,
  answer("Too much manual typing!", correct = TRUE),
  answer("But I like typing..."),
  answer("Wait, what is a drake plan?")
)
```

## Static branching

To avoid excessive typing, `drake` has a special [static branching](https://books.ropensci.org/drake/static.html) interface. Below, `transform = map()` declares a new model run for every activation function.

```{r, echo = TRUE, paged.print = FALSE}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    test_model(act1 = act, churn_data, churn_recipe),
    transform = map(
      act = c(
        "elu", "selu", "hard_sigmoid", "linear",
        "softplus", "softsign", "tanh", "exponential"
      )
    )
  )
)
```

```{r convenient}
question(
  "Sound convenient?",
  correct = laud(),
  incorrect = "Let's talk.",
  allow_retry = TRUE,
  answer("Yes.", correct = TRUE),
  answer("I am not convinced.")
)
```

## A larger map

A single `map()` can take multiple grouping variables. Follow the instructions in the comments below to set a different layer size for each activation function.

Use the [drakeplanner](https://wlandau.shinyapps.io/drakeplanner) app to help you match your plan to the expected results below. When you are ready, click `Submit Answer` at the top right of the text editor.

```{r largermap, exercise = TRUE, exercise.lines = 16, paged.print = FALSE}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    # Note: we are now using the units1 argument of test_model().
    test_model(act1 = act, units1 = units, churn_data, churn_recipe),
    transform = map(
      act = c(
        "elu", "selu", "hard_sigmoid", "linear",
        "softplus", "softsign", "tanh", "exponential"
      ),
      # Your turn: set units1 equal to c(16, 17, 18, 19, 20, 21, 22, 23).
      units = # ...
    )
  )
)
```

Expected [drakeplanner](https://wlandau.shinyapps.io/drakeplanner) output:

```{r}
expected <- drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    test_model(act1 = act, units1 = units, churn_data, churn_recipe),
    transform = map(
      act = c(
        "elu", "selu", "hard_sigmoid", "linear",
        "softplus", "softsign", "tanh", "exponential"
      ),
      units = c(16, 17, 18, 19, 20, 21, 22, 23)
    )
  )
)
```

```{r}
dp_graph(expected)
```

```{r}
dp_table(expected)
```

```{r largermap-check}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    test_model(act1 = act, units1 = units, churn_data, churn_recipe),
    transform = map(
      act = c(
        "elu", "selu", "hard_sigmoid", "linear",
        "softplus", "softsign", "tanh", "exponential"
      ),
      units = c(16, 17, 18, 19, 20, 21, 22, 23)
    )
  )
)
```

## Map over symbols

Static branching is all about [symbols and expressions](https://adv-r.hadley.nz/expressions.html). Below, `transform = map(fun_run = c(good_run, bad_run, benchmark_run)` tells `drake_plan()` to find the symbol `fun_run` and replace it with `good_run`, then `bad_run`, and then `benchmark_run`. This handy trick lets you map over *functions*. Try it out in the plan below.

As before, use the [drakeplanner](https://wlandau.shinyapps.io/drakeplanner) app to help you match your plan to the expected results below. When you are ready, click `Submit Answer` at the top right of the text editor.

```{r symbolmap, exercise = TRUE, exercise.lines = 9, paged.print = FALSE}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    fun_run(churn_data, churn_recipe),
    # Write fun_run = c(good_run, bad_run, benchmark_run) inside map() below.
    transform = map()
  )
)
```

Expected [drakeplanner](https://wlandau.shinyapps.io/drakeplanner) output:

```{r}
expected <- drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    fun_run(churn_data, churn_recipe),
    transform = map(fun_run = c(good_run, bad_run, benchmark_run))
  )
)
```

```{r}
dp_graph(expected)
```

```{r}
dp_table(expected)
```

```{r symbolmap-check}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    fun_run(churn_data, churn_recipe),
    transform = map(fun_run = c(good_run, bad_run, benchmark_run))
  )
)
```


## Concise maps

`units = c(16, 17, 18, 19, 20, 21, 22, 23)` should be equivalent to `units = 16:23`, but we get the wrong answer when we try it in the plan.

```{r, echo = TRUE, paged.print = FALSE}
drake_plan(
  churn_data = split_data(file_in("data/customer_churn.csv")),
  churn_recipe = prepare_recipe(churn_data), 
  run = target(
    test_model(act1 = act, units1 = units, churn_data, churn_recipe),
    transform = map(
      act = c(
        "elu", "selu", "hard_sigmoid", "linear",
        "softplus", "softsign", "tanh", "exponential"
      ),
      units = 16:23
    )
  )
)
```

```{r concisefail}
question(
  "Why does units1 cycle between 16 and 32?",
  correct = laud(),
  incorrect = "Let's talk.",
  allow_retry = TRUE,
  random_answer_order = TRUE,
  answer("`drake_plan()` is all about symbols and expressions. It does not actually evaluate the expression `16:32`. It only sees the symbols `16` and `32`.", correct = TRUE),
  answer("This behavior is due to a bug in `drake_plan()`."),
  answer("The plan is actually correct.")
)
```

